{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fnil\fcharset0 Courier New;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red0\green0\blue153;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}{\s4 heading 4;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\s1\sa120\sl276\slmult1\cf1\b\f0\fs48 GameMenu\par
\pard\s1\sb480\sa120\sl276\slmult1\qj\b0\fs22 This is an Android application aimed at improving the experience of an american bar customer.\par
\pard\s2\sb360\sa80\sl276\slmult1\qj\b\fs36 1. The project\par
\b0\fs22 This software is developed as an UNIPD project for the Embedded Systems course (a.y. 2010/2011). Main page of the course is at\b\fs36{\field{\*\fldinst{HYPERLINK "http://es1011.wikispaces.com/"}}{\fldrslt{\b0\fs22  \b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 http\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 ://\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 es\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 1011.\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 wikispaces\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 .\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 com\cf1\ulnone\b\v\fs36 HYPERLINK "http://es1011.wikispaces.com/"\cf3\ul\b0\v0\fs22 /}}}\cf1\ulnone\f0\fs22\par
\b\fs36 2. Usage\par
\b0\fs22 This repository has been uploaded using Eclipse with the Egit plugin. To use it, first set up a development environment as per the official Android documentation (e.g. install Eclipse, install and set up the Android SDK, install Egit). Then get a copy of this repository. If Eclipse says the project properties are not correct, right click on the project, select "Android tools" from the menu, then select "Fix project properties".\par
Since the Android SDK auto-generates a resources file (R.java), but this is NOT tracked with git, you should force its creation. The simplest way is to edit an XML from /res/layout (e.g. add and delete a space) and save it. Eclipse will update (and create) R.java. To use the app you should have a real device, since the game uses the accelerometer to move the pad.\par
\b\fs36\par
\pard\pagebb\s2\sb360\sa80\sl276\slmult1\qj 3. The application\par
\pard\s2\sb360\sa80\sl276\slmult1\qj\b0\fs22 The app is organized in three tabs; the first one is relative to the drink list, drink details and current order. The second tab enables the user to take a photo of its table number and send it to the waiter, to call him. The third tab contains a little game, to entertain the user while he waits for his drinks.\par
\pard\s3\sb280\sa80\sl276\slmult1\qj\b\fs28 The main TabActivity\par
\b0\fs22 The TabActivity that hosts all other activities is in the \b\f1 GameMenu \b0\f0 class. It just instantiates the tabs and attaches to them an intent that starts the related activity.\par
\b\fs28 The drink list tab\par
\b0\fs22 The main purpose of this activity is to show a simple usage of a database to store and retrieve informations about a drink list and a current drink order. This activity is structured like a Content Management System: there are three XML layouts that are loaded on the fly as pages are swapped. There is a drink list page, a current order page, and a drink details page. If the activity has been shown previously, the last page will be shown again; otherwise the drink list will be shown. This activity permits screen orientation changes, and displays three alternative pages in landscape mode (stored in res/layout-land). This functionality is handled automatically by the Android OS.\par
\pard\s4\sb240\sa40\sl276\slmult1\qj\b\fs24 GUI\par
\b0\fs22 The user can switch from the drink list to the current order and back again, and when he taps on an item in the drink list or in the current order a "details" page is shown. From the details page the user can increment or decrement the ordered quantity of that particular drink; if the drink was not in the order it will be inserted. To go back from the details page a "last page" pointer is kept.\par
The drink_list layout contains a linear layout; a first child is horizontally split in two, and contains the current order total and a button to switch to the current order page. This upper part is fixed, and does not scroll with the list. Under the button there is a scrollable linear layout that will contain the full list of drinks available. In the landscape version the drink list is on the left, and is scrollable, while the order total and the button to change page are on the right, and are fixed.\par
The drink_order layout is similar to the drink_list one, except that a custom view (\b\f1 LinearListView\b0\f0 ) is used to avoid automatic scrolling of the order list. Under the ordered drinks there are the order summary and buttons to clear/send the order or go back to the full list. The portrait layout is fully scrollable, and the user has to reach the end of the list to read the total items and total cost. In the landscape version only the drink list scrolls, while the order summary and the buttons stay still on the right.\par
The drink_details layout contains the bigger picture of the drink, its cost, its name, and a TextView with its full description (actually, a lorem ipsum). At the end of the page are the buttons to increment/decrement the ordered quantity, and a "back" button that goes to the last shown page. The landscape version splits the information on the drink and the buttons. Buttons are placed on the right, while drink information is kept on the left. Just to try a different layout, the full page scrolls.\par
A helper layout also belongs to this section; \b\f1 drink_listitem \b0\f0 is a layout used for each item in the drink lists. It contains an ImageView on the far left, a TextView on the center left, and a TextView aligned to the right.\par
\b\fs24 Objects and database\par
\b0\fs22 Apart from the Activity, only a single View has been made to fit the project. \b\f1 LinearListView \b0\f0 implements a simple LinearLayout with a simple DataSetObserver and a ParameterizedClickListener. Its sole purpose is to display a clickable list of drinks that does not automatically scroll. On the \b\f1 onChanged \b0\f0 event (referred to the DataSet being observed), the object populates itself with the views from the data adapter.\par
\b\f1 Drink_ImageListAdapter \b0\f0 provides such a data adapter, and inflates a \b\f1 drink_listitem \b0\f0 layout for every item in the dataset required. The inflated layout is also populated with data from the item. Drink images are stored in the database as names, and the \b\f1 Drink_ImageListAdapter \b0\f0 loads them from the PNG in the resources.\b\f1\par
\b0\f0 Two more objects, namely \b\f1 Drink_Order \b0\f0 and \b\f1 Drink_OriginalList \b0\f0 hide the abstraction of the current order model and the original list model. Such objects access the database in similar ways, instantiating an SQLiteOpenHelper and executing simple queries. The \b\f1 Drink_OriginalList \b0\f0 model handles database creation and population with dummy data, and exposes methods to retrieve the full list of drinks and details about a particular drink.\par
The \b\f1 Drink_Order \b0\f0 model does not do anything particular on database creation (creates the current order table), but exposes many methods to insert and update drink quantities into the table. Many drink details are duplicated for simplicity, and the whole data access model is not optimized for performance.\par
Database is kept between shutdowns of the activity, so the current order is persisted this way. The current page is not an important information to keep, so it is persisted on the Bundle object (this is to make for a nice and simple screen-rotation handling). Both when the order is "cleared" or "sent" the table of the database containing the order is actually cleared. Anyway, different \b\f1 toast \b0\f0 messages are displayed.\par
\pard\s3\sb280\sa80\sl276\slmult1\qj\b\fs28 The waiter call tab\par
\b0\fs22 The sole purpose of this tab is to demonstrate access to the hardware of the device; the focus is on the camera and location services. The supposed function is to send a photo and a location to the waiter, for him to reach the table. Upon creation a handle to the location manager is obtained. When the activity resumes, the location manager is asked to signal to the appropriate handler any location updates, and the camera preview is started. Camera preview is rotated to compensate for screen rotation: although the camera top left pixel is always still with respect to the phone, the top left pixel of the screen is changed on rotation. The \b\f1 correctOrientation()\b0\f0  subroutine handles this situation. Camera preview and location updates are halted when the activity loses focus, to save battery.\par
If location services are not enabled on the device, the system configuration screen is invoked (see first lines of \b\f1 EnableGPS()\b0\f0  in \b\f1 ActWaiterCall\b0\f0 ); if the user dismisses that he will not be asked anymore.\par
When the user taps on the part of the screen devoted to the activity, \b\f1 takePicture()\b0\f0  is invoked on the camera. When the specified callback object is notified that a photo has been shot, it just saves the jpeg to a file and the current GPS location to another file. It then displays a \b\f1 toast\b0\f0  message, simulating a successful notification to the waiter.\par
\b\fs28 The game entertainer tab\par
\b0\fs22 This activity has the main purpose of demonstrating access to the accelerometer data. Other functionality demonstrated here is locking the screen backlight on, threading, canvas drawing and a menu connected to the MENU button on the device. The implemented game is a classic brick breaker, where the brick number is incremented as the level increases and the pad is moved by tilting the device. The game, once started, instantiates a particular subclass of SurfaceView (called \b\f1 Game_View\b0\f0 ), a \b\f1 Game_Status \b0\f0 object, and locks the screen backlight on. If the activity loses foreground the View is immediately notified (so some simple teardown is performed, to save battery life) and the screen backlight lock is released.\par
The game screen should not be rotated; the code in the startup/teardown sections of the activity handles this requirement too.\par
All the game logic is hard-coded into the \b\f1 Game_Thread \b0\f0 object, inside the \b\f1 Game_View \b0\f0 class. This thread, since it is defined as an internal class of a SurfaceView, can use the same surface holder object. This is important because only the thread that owns a SurfaceView can draw on it, and implementing some sort of other message-passing among threads would have caused too much delay. The main game loop begins with the thread creation, and performs some basic status update (ball position, bounding box checks) and draws the PNG files from the resources on the surface.\par
The \b\f1 Game_Status \b0\f0 object exposes methods for resetting a game, increment the level or lose a life.\par
The Activity (\b\f1 ActGameEntertainer\b0\f0 ) registers itself as a listener for accelerometer events, sets up the backlight lock and creates the surface object. On an accelerometer event, the pad speed in the \b\f1 Game_Status \b0\f0 object is directly adjusted. The Activity saves and restores game data from a Bundle object, to handle simple restarts (but no persistence on file or database is provided). \b\f1 ActGameEntertainer \b0\f0 provides also a simple contextual MENU, with only one entry, that restarts the game from scratch (calling an appropriate method on \b\f1 Game_Status\b0\f0 ).\par
The \b\f1 Game_View \b0\f0 object creates a \b\f1 Game_Thread \b0\f0 and starts it when the surface is actually created (thread start is handled in the \b\f1 surfaceCreated()\b0\f0  event). When the View is destroyed the thread is gracefully stopped (by using an internal status variable and a \b\f1 join()\b0\f0  call).\par
The thread has two status variables: \b\f1 bRun \b0\f0 and \b\f1 sStatus\b0\f0 . \b\f1 bRun \b0\f0 should be set to true as long as the game is needed, as setting it to false will cause the thread to exit its \b\f1 run()\b0\f0  cycle. \b\f1 sStatus \b0\f0 controls the variables update: when it is set to false the draw loop is executed but the update branch is not taken (i.e. the ball and pad stand still). The \b\f1 updateGame()\b0\f0  routine checks for collisions, with the classic bounding box algorythm; the \b\f1 doDraw()\b0\f0  routine draws all the PNGs and rectangles/texts on the canvas attached to the surface.\par
As a little feature, the horizontal speed of the ball is incremented/decremented with the speed of the pad when the collision occurs, to give some unpredictability to the game.\par
A lot of synchronization is involved in the thread operations, mainly to avoid accessing the surface holder while it's being used to have a canvas.\par
\pard\s2\sb360\sa80\sl276\slmult1\qj\b\fs36 4. Known bugs\par
\b0\fs22 There is a known bug on returning from the game tab to the camera tab; the camera preview is not displayed anymore although the camera is correctly started and can take photos.\par
\pard\sl276\slmult1\qj\par
}
 